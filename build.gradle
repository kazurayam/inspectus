plugins {
    id("maven-publish")
    id("signing")
}

group = "com.kazurayam"
version = "0.1.0"

ext {
    isReleaseVersion = !version.endsWith("SNAPSHOT")
    ancestorProjectsName = { proj, str = "" ->
        if (proj.name == rootProject.name) {
            str = rootProject.name
        } else {
            str = ancestorProjectsName(proj.parent) + "-" + proj.name
        }
        return str
    }
    resolveArchiveBaseName = { subproj ->
        return ancestorProjectsName(subproj)
    }
}

allprojects {
    apply(plugin: "java")
    repositories {
        mavenCentral()
        mavenLocal()
    }
    sourceCompatibility = "1.8"
    targetCompatibility = "1.8"
    def defaultEncoding = "UTF-8"
    tasks.withType(AbstractCompile).each { it.options.encoding = defaultEncoding }
    tasks.withType(GroovyCompile).each { it.groovyOptions.encoding = defaultEncoding }
    tasks.withType(JavaCompile) {
        options.compilerArgs << "-Xlint:unchecked" << "-Xlint:deprecation"
    }
}



subprojects({ subproject ->
    apply(plugin: "jacoco")
    test({
        useJUnitPlatform()
        finalizedBy(jacocoTestReport)
    })
    dependencies({
        // Gson is required by com.kazurayam.materialstore.filesystem.TemplateReady
        implementation(libs.gson)

        // slf4j is required by many classes in this library
        implementation(libs.slf4j.api)
        testImplementation(libs.slf4j.simple)

        // https://mvnrepository.com/artifact/commons-io/commons-io
        testImplementation(libs.commons.io)

        // JUnit Jupiter is used by all unit tests of all subprojects
        testImplementation(libs.junit.jupiter)
        testImplementation(libs.junit.jupiter.api)
        testRuntimeOnly(libs.junit.jupiter.engine)
    })

    jar({
        archiveBaseName.set(resolveArchiveBaseName(subproject))
        archiveVersion.set(rootProject.version)
    })

    javadoc({
        options.showFromProtected()
        failOnError = false
        options.locale = "en_US"
    })

    task submission(type: Zip, {
        destinationDirectory = file("${buildDir}/libs")
        archiveBaseName.set(resolveArchiveBaseName(subproject))
        archiveVersion.set(rootProject.version)
        //archiveFileName = subproject.name + ".self-contained" + ".zip"
        from(".")
        exclude("build")
    })

    task showSourceSets({
        doLast({
            sourceSets.each({ srcSet ->
                println("[" + srcSet.name + "]")
                println("--> Source directories: " + srcSet.allJava.srcDirs)
                println("--> Output directories: " + srcSet.output.classesDirs.files)
                println("--> Compile classpath:")
                srcSet.compileClasspath.files.each({
                    println "  " + it.path
                })
                println("")
            })
        })
    })

    task showDependencies({
        doFirst({
            println("dependencies {")
            configurations.each({config ->
                if (config.name != "") {
                    config.dependencies.each({ dependency ->
                        println "    ${config.name} group: "${dependency.group}", name: "${dependency.name}", version: "${dependency.version}""
                    })
                }
            })
            println("}")
        })
    })

    task showConfigurations({
        doLast({
            configurations.each({
                println(it.getName())
                it.getExtendsFrom().forEach({
                    println("    extends from " + it.getName())
                })
            })
        })
    })

    task printDependencies(type: DependencyReportTask) {}
})

task aggregateDocsImages, {
    copy({
        from("freemarker/docs/images")
        into("docs/images")
    })
}

task allJar(type: Jar, dependsOn: subprojects.jar, {
    from subprojects.collect { subproject ->
        subproject.sourceSets.main.output
    }
    archivesBaseName = rootProject.name
    duplicatesStrategy("exclude")
})

task allJavadoc(type: Javadoc) {
    group = "aggregation"
    description = rootProject.name
    title = "$description $version API"
    destinationDir = file("${buildDir}/docs/javadoc")
    def sourceProjects =
            subprojects.findAll {
                it.plugins.hasPlugin("java") || it.plugins.hasPlugin("groovy")
            }
    source sourceProjects.collect { prj -> prj.sourceSets.main.allJava }
    classpath = files(sourceProjects.collect { prj -> prj.sourceSets.main.runtimeClasspath })

    options.overview = "gradle/api/overview.html"
    options.showFromProtected()
    failOnError = false
    options.locale = "en_US"
}
task copyJavadocToDocsDir(type: Copy) {
    from "build/docs/javadoc"
    into "docs/api"
}
allJavadoc.finalizedBy copyJavadocToDocsDir

task javadocJar(type: Jar) {
    archiveClassifier.set("javadoc")
    from allJavadoc
}

task sourcesJar(type: Jar) {
    from subprojects.collect {subproject ->
        subproject.sourceSets.main.allSource
    }
    archivesBaseName = rootProject.name
    archiveClassifier.set("sources")
}

publishing {
    publications {
        materialstore(MavenPublication) {
            artifact allJar
            artifact sourcesJar
            artifact javadocJar
            pom {
                groupId = project.group
                name = project.rootProject.name
                description = "A Java/Groovy API to store objects (Screenshots, HTML, JSON, XML) collected during End-to-end testings empowered by diffing and reporting tools"
                url = "https://kazurayam.github.io/materialstore/"
                licenses {
                    license {
                        name = "The Apache License, Version 2.0"
                        url = "https://www.apache.org.licenses/LICENSE-2.0.txt"
                    }
                }
                developers {
                    developer {
                        id = "kazurayam"
                        name = "URAYAMA,kazuaki"
                        email = "kazuaki.urayama@gmail.com"
                    }
                }
                scm {
                    connection = "scm:git:https://github.com/kazurayam/${project.rootProject.name}.git"
                    developerConnection = "scm:git:git@github.com:kazurayam/${project.rootProject.name}.git"
                    url = "https://github.com/kazurayam/${project.rootProject.name}"
                }
            }
        }
    }
    repositories {
        maven {
            def releaseRepo = "https://s01.oss.sonatype.org/service/local/staging/deploy/maven2/"
            def snapshotRepo = "https://s01.oss.sonatype.org/content/repositories/snapshots/"
            url = isReleaseVersion ? releaseRepo: snapshotRepo
            credentials {
                username = project.hasProperty("ossrhUsername") ? ossrhUsername : "Unknown user"
                password = project.hasProperty("ossrhPassword") ? ossrhPassword : "Unknown password"
            }
        }
    }
}

signing {
    sign publishing.publications.materialstore
}

// I do not want to sign the SNAPSHOT
tasks.withType(Sign) {
    onlyIf { isReleaseVersion }
}